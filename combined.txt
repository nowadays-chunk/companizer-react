

===== FILE: BaseModal.js =====

import React, { useState } from 'react';
import { Dialog, DialogTitle, DialogContent, DialogActions, Button, TextField } from '@mui/material';

export default function BaseModal({ open, onClose, onSubmit, initialData, fieldConfig }) {
  const [formData, setFormData] = useState(initialData || {});

  const handleChange = (key, value) => {
    setFormData({ ...formData, [key]: value });
  };

  const handleSubmit = () => {
    onSubmit(formData);
  };

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle>{initialData ? 'Edit Item' : 'Add Item'}</DialogTitle>
      <DialogContent>
        {Object.keys(fieldConfig).map((key) => (
          <TextField
            key={key}
            label={fieldConfig[key].label}
            value={formData[key] || ''}
            onChange={(e) => handleChange(key, e.target.value)}
            fullWidth
            margin="normal"
          />
        ))}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose} color="primary">
          Cancel
        </Button>
        <Button onClick={handleSubmit} color="primary">
          Save
        </Button>
      </DialogActions>
    </Dialog>
  );
}
    

===== FILE: BaseTable.js =====

import React, { useEffect } from 'react';
import { Box, Table, TableBody,Checkbox, TableCell, TableContainer, TablePagination, TableRow } from '@mui/material';

import BaseTableHead from './BaseTableHead';

function descendingComparator(a, b, orderBy) {
  if (b[orderBy] < a[orderBy]) {
    return -1;
  }
  if (b[orderBy] > a[orderBy]) {
    return 1;
  }
  return 0;
}

function getComparator(order, orderBy) {
  return order === 'desc'
    ? (a, b) => descendingComparator(a, b, orderBy)
    : (a, b) => -descendingComparator(a, b, orderBy);
}

function stableSort(array, comparator) {
  const stabilizedThis = array.map((el, index) => [el, index]);
  stabilizedThis.sort((a, b) => {
    const order = comparator(a[0], b[0]);
    if (order !== 0) return order;
    return a[1] - b[1];
  });
  return stabilizedThis.map((el) => el[0]);
}

const truncateText = (text) => {
  if(text.length > 200){
    return text.slice(0, 200);
  }
  return text;
};

function BaseTable({
  items,
  order,
  setOrder,         // Add this to receive the prop
  orderBy,
  setOrderBy,       // Add this to receive the prop
  selected,
  setSelected,
  page,
  setPage,
  rowsPerPage,
  setRowsPerPage,
  dense,
  setDense,
  fieldConfig,
}) {

  const handleRequestSort = (event, property) => {
    const isAsc = orderBy === property && order === 'asc';
    setOrder(isAsc ? 'desc' : 'asc');
    setOrderBy(property);
  };

  const handleSelectAllClick = (event) => {
    if (event.target.checked) {
      const newSelected = items.map((n) => n.id);
      setSelected(newSelected);
      return;
    }
    setSelected([]);
  };

  const handleClick = (event, id) => {
    const selectedIndex = selected.indexOf(id);
    let newSelected = [];

    if (selectedIndex === -1) {
      newSelected = newSelected.concat(selected, id);
    } else if (selectedIndex === 0) {
      newSelected = newSelected.concat(selected.slice(1));
    } else if (selectedIndex === selected.length - 1) {
      newSelected = newSelected.concat(selected.slice(0, -1));
    } else if (selectedIndex > 0) {
      newSelected = newSelected.concat(selected.slice(0, selectedIndex), selected.slice(selectedIndex + 1));
    }
    setSelected(newSelected);
  };

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const isSelected = (id) => selected.indexOf(id) !== -1;

  const emptyRows = page > 0 ? Math.max(0, (1 + page) * rowsPerPage - items.length) : 0;

  const visibleRows = React.useMemo(() => stableSort(items, getComparator(order, orderBy)).slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage), [items, order, orderBy, page, rowsPerPage]);

  return (
    <Box>
      <TableContainer>
        <Table sx={{ minWidth: 750 }} size={dense ? 'small' : 'medium'}>
          <BaseTableHead
            headCells={Object.keys(fieldConfig).map((key) => ({
              id: key,
              label: fieldConfig[key].label,
            }))}
            order={order}
            orderBy={orderBy}
            onRequestSort={handleRequestSort}
            onSelectAllClick={handleSelectAllClick}
            numSelected={selected.length}
            rowCount={items.length}
          />
          <TableBody>
            {visibleRows.map((row, index) => {
              const isItemSelected = isSelected(row.id);
              const labelId = `enhanced-table-checkbox-${index}`;

              return (
                <TableRow
                  hover
                  onClick={(event) => handleClick(event, row.id)}
                  role="checkbox"
                  aria-checked={isItemSelected}
                  tabIndex={-1}
                  key={row.id}
                  selected={isItemSelected}
                >
                  <TableCell padding="checkbox">
                    <Checkbox color="primary" checked={isItemSelected} inputProps={{ 'aria-labelledby': labelId }} />
                  </TableCell>

                  {Object.keys(fieldConfig).map((field) => (
                    <TableCell
                      size="medium"
                      key={field}
                      align={fieldConfig[field].numeric ? 'right' : 'left'}
                      sx={{ maxWidth: 300, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }} // Set maxWidth and text overflow styles
                    >
                      {row[field]}
                    </TableCell>
                  ))}
                </TableRow>
              );
            })}
            {emptyRows > 0 && (
              <TableRow style={{ height: (dense ? 33 : 53) * emptyRows }}>
                <TableCell colSpan={6} />
              </TableRow>
            )}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[15, 25, 50]}
        component="div"
        count={items.length}
        rowsPerPage={rowsPerPage}
        page={page}
        onPageChange={handleChangePage}
        onRowsPerPageChange={handleChangeRowsPerPage}
      />
    </Box>
  );
}

export default BaseTable;


===== FILE: BaseTableHead.js =====

import React from 'react';
import { TableHead, TableRow, TableCell, TableSortLabel, Checkbox } from '@mui/material';

export default function BaseTableHead({ headCells, order, orderBy, onRequestSort, onSelectAllClick, numSelected, rowCount }) {
  const createSortHandler = (property) => (event) => {
    onRequestSort(event, property);
  };

  return (
    <TableHead>
      <TableRow>
        <TableCell padding="checkbox">
          <Checkbox
            indeterminate={numSelected > 0 && numSelected < rowCount}
            checked={rowCount > 0 && numSelected === rowCount}
            onChange={onSelectAllClick}
            inputProps={{ 'aria-label': 'select all items' }}
          />
        </TableCell>
        {headCells.map((headCell) => (
          <TableCell key={headCell.id} align={headCell.numeric ? 'right' : 'left'} sortDirection={orderBy === headCell.id ? order : false}>
            <TableSortLabel
              active={orderBy === headCell.id}
              direction={orderBy === headCell.id ? order : 'asc'}
              onClick={createSortHandler(headCell.id)}
            >
              {headCell.label}
            </TableSortLabel>
          </TableCell>
        ))}
      </TableRow>
    </TableHead>
  );
}


===== FILE: BaseTableToolbar.js =====

import React from 'react';
import { Toolbar, Typography, IconButton, Tooltip } from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';

export default function BaseTableToolbar({ numSelected, onAdd, onDelete, onEdit, entityName }) {
  return (
    <Toolbar>
      <Typography sx={{ flex: '1 1 100%' }} variant="h6" id="tableTitle" component="div">
        {entityName}
      </Typography>
      {numSelected > 0 && (
        <>
          {
            numSelected !== 1 ? (
              <IconButton onClick={onEdit} disabled={true}>
                <EditIcon />
              </IconButton>
            ) : (
              <Tooltip title="Edit">
                <IconButton onClick={onEdit}>
                  <EditIcon />
                </IconButton>
              </Tooltip>
            )
          }
          <Tooltip title="Delete">
            <IconButton onClick={onDelete}>
              <DeleteIcon />
            </IconButton>
          </Tooltip>
        </>
      )}
      <Tooltip title="Add">
        <IconButton onClick={onAdd}>
          <AddIcon />
        </IconButton>
      </Tooltip>
    </Toolbar>
  );
}


===== FILE: FilterManager.js =====

import React from 'react';
import { Box, Button, IconButton, TextField, Select, MenuItem, FormControl, InputLabel } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';

export default function FilterManager({ filters, setFilters, fieldConfig }) {
  const handleAddFilter = () => {
    setFilters([...filters, { column: '', value: '', active: true }]);
  };

  const handleFilterChange = (index, key, value) => {
    const newFilters = filters.slice();
    newFilters[index][key] = value;
    setFilters(newFilters);
  };

  const handleRemoveFilter = (index) => {
    const newFilters = filters.slice();
    newFilters.splice(index, 1);
    setFilters(newFilters);
  };

  return (
    <Box sx={{ mb: 2 }}>
      {filters.map((filter, index) => (
        <Box key={index} sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <FormControl sx={{ minWidth: 120 }}>
            <InputLabel>Column</InputLabel>
            <Select value={filter.column} onChange={(e) => handleFilterChange(index, 'column', e.target.value)}>
              {Object.keys(fieldConfig).map((key) => (
                <MenuItem key={key} value={key}>
                  {fieldConfig[key].label}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
          <TextField
            label="Value"
            value={filter.value}
            onChange={(e) => handleFilterChange(index, 'value', e.target.value)}
            sx={{ ml: 2 }}
          />
          <IconButton onClick={() => handleRemoveFilter(index)} sx={{ ml: 2 }}>
            <DeleteIcon />
          </IconButton>
        </Box>
      ))}
      <Button variant="contained" onClick={handleAddFilter} startIcon={<AddIcon />}>
        Add Filter
      </Button>
    </Box>
  );
}


===== FILE: index.js =====

import React, { useState, useEffect } from 'react';
import {
  Box,
  Container,
  Paper,
  Button,
  CircularProgress,
  Backdrop,
  FormControlLabel,
  Switch,
} from '@mui/material';

import FilterManager from './FilterManager';
import BaseTableToolbar from './BaseTableToolbar';
import BaseTable from './BaseTable.js';
import { keyToLinkMap } from '../../../layout/keyToLinkMap';
import { faker } from '@faker-js/faker';

const getRandomElementId = (options) => {
  if (!options || options.length === 0) return null;
  return options[Math.floor(Math.random() * options.length)].id;
};

const getMultipleRandomElementIds = (options) => {
  if (!options || options.length === 0) return [];
  const selectedOptions = [];
  const maxSelections = Math.min(3, options.length); // no more than 3 and not more than available options
  const numSelections = Math.floor(Math.random() * maxSelections) + 1; // 1..maxSelections

  while (selectedOptions.length < numSelections) {
    const option = getRandomElementId(options);
    if (!selectedOptions.includes(option)) {
      selectedOptions.push(option);
    }
  }

  return selectedOptions;
};

// ----- generic numeric helper obeying min / max / decimals -----
const getRandomNumberInRange = (min = 0, max = 1000, decimals = 0) => {
  const rand = Math.random() * (max - min) + min;
  if (decimals > 0) {
    return Number(rand.toFixed(decimals));
  }
  return Math.round(rand);
};

// ----- UPDATED: date helper returning MySQL DATETIME string -----
const getRandomDateISO = (mode = 'past') => {
  const now = new Date();
  const threeYears = 1000 * 60 * 60 * 24 * 365 * 3;
  let ts;

  if (mode === 'future') {
    ts = now.getTime() + Math.random() * threeYears;
  } else if (mode === 'past') {
    ts = now.getTime() - Math.random() * threeYears;
  } else {
    ts = now.getTime() - threeYears / 2 + Math.random() * threeYears;
  }

  const d = new Date(ts);
  const pad = (n) => String(n).padStart(2, '0');

  // MySQL DATETIME(6) accepts this format just fine
  return (
    `${d.getFullYear()}-` +
    `${pad(d.getMonth() + 1)}-` +
    `${pad(d.getDate())} ` +
    `${pad(d.getHours())}:` +
    `${pad(d.getMinutes())}:` +
    `${pad(d.getSeconds())}`
  );
};

export default function BaseTableComponent({
  fetchItems,
  addItem,
  updateItem,
  deleteItem,
  fieldConfig,
  entityName,
}) {
  const [refreshedFieldsConfig, setRefreshedFieldsConfig] = useState(fieldConfig);
  const [order, setOrder] = useState('asc');
  const [orderBy, setOrderBy] = useState(Object.keys(fieldConfig)[0]);
  const [selected, setSelected] = useState([]);
  const [page, setPage] = useState(0);
  const [dense, setDense] = useState(false);
  const [rowsPerPage, setRowsPerPage] = useState(15);
  const [items, setItems] = useState([]);
  const [filteredItems, setFilteredItems] = useState([]);
  const [filters, setFilters] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    setRefreshedFieldsConfig(fieldConfig);
  }, [fieldConfig]);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      const data = await fetchItems();
      setItems(data);
      setLoading(false);
    };

    fetchData();
    setSelected([]);
  }, [fetchItems]);

  useEffect(() => {
    let filteredData = items;

    filters.forEach((filter) => {
      if (filter.active && filter.column && filter.value) {
        filteredData = filteredData.filter((item) =>
          item[filter.column]?.toString().toLowerCase().includes(filter.value.toLowerCase())
        );
      }
    });

    setFilteredItems(filteredData);
  }, [filters, items]);

  const getBaseSlashedURL = () => {
    return keyToLinkMap[entityName.toLowerCase().replace(/ /g, '-')];
  };

  const openTabsForSelected = (mode) => {
    const baseSlashedURL = getBaseSlashedURL();
    if (!baseSlashedURL || selected.length === 0) return;

    selected.forEach((id) => {
      const url = `/#${baseSlashedURL}/${mode}/${id}`;
      window.open(url, '_blank', 'noopener,noreferrer');
    });
  };

  // CREATE -> open single "create" page (no need for selection)
  const handleAddItem = () => {
    const baseSlashedURL = getBaseSlashedURL();
    if (!baseSlashedURL) return;

    const url = `/#${baseSlashedURL}/create`;
    window.open(url, '_blank', 'noopener,noreferrer');
  };

  // EDIT -> open edit tab for each selected item
  const handleEditItem = () => {
    if (selected.length === 0) return;
    openTabsForSelected('edit');
  };

  // VIEW -> open view tab for each selected item
  const handleViewItem = () => {
    if (selected.length === 0) return;
    openTabsForSelected('view');
  };

  const handleDeleteItems = async () => {
    if (!selected.length) return;

    if (window.confirm('Are you sure you want to delete the selected items?')) {
      setLoading(true);
      for (const id of selected) {
        await deleteItem(id);
      }
      setSelected([]);
      const data = await fetchItems();
      setItems(data);
      setLoading(false);
    }
  };

  // NOTE: addItem / updateItem are still available if you want
  // to keep "Generate Random Row" using the API directly.
  const generateRandomRow = async () => {
    try {
      const newRow = Object.entries(refreshedFieldsConfig).reduce(
        (acc, [key, field]) => {
          let value;

          // 1) SELECT fields (single & multiple)
          if (field.type === 'select') {
            if (field.multiple) {
              value = getMultipleRandomElementIds(field.options);
            } else {
              value = getRandomElementId(field.options);
            }
          }
          // 2) DATE fields -> MySQL DATETIME string (past or future)
          else if (field.type === 'date') {
            if (field.faker === 'date.future') {
              value = getRandomDateISO('future');
            } else if (field.faker === 'date.past') {
              value = getRandomDateISO('past');
            } else {
              // generic date
              value = getRandomDateISO();
            }
          }
          // 3) NUMBER fields -> use min / max / decimals from fieldConfig
          else if (field.type === 'number') {
            const min = field.min ?? 0;
            const max = field.max ?? 1000;
            const decimals = field.decimals ?? 0;
            value = getRandomNumberInRange(min, max, decimals);
          }
          // 4) SPECIAL case: date.month (even if type is "text")
          else if (field.faker === 'date.month') {
            const monthIndex = Math.floor(Math.random() * 12); // 0..11
            const month = new Date(0, monthIndex).toLocaleString('default', {
              month: 'long',
            });
            value = month.charAt(0).toUpperCase() + month.slice(1);
          }
          // 5) Generic faker for text/etc
          else if (field.faker) {
            try {
              const fakerFnOrVal = field.faker
                .split('.')
                .reduce((accObj, method) => accObj?.[method], faker);

              value =
                typeof fakerFnOrVal === 'function'
                  ? fakerFnOrVal()
                  : fakerFnOrVal ?? faker.lorem.word();
            } catch (e) {
              // fallback if faker path is wrong
              value = faker.lorem.word();
            }
          } else {
            // 6) Fallbacks when nothing else is defined
            if (field.type === 'number') {
              const min = field.min ?? 0;
              const max = field.max ?? 1000;
              const decimals = field.decimals ?? 0;
              value = getRandomNumberInRange(min, max, decimals);
            } else if (field.type === 'date') {
              value = getRandomDateISO();
            } else {
              value = faker.lorem.word();
            }
          }

          acc[key] = value;
          return acc;
        },
        {}
      );

      console.log('New row : ', newRow);
      await addItem(newRow);
      const data = await fetchItems();
      setItems(data);
    } catch (error) {
      console.error(`Error generating and saving random ${entityName}:`, error);
    }
  };

  return (
    <Container maxWidth="xl" sx={{ paddingTop: 3, paddingBottom: 7 }}>
      <Box sx={{ maxWidth: '80vw', position: 'relative' }}>
        <FilterManager
          filters={filters}
          setFilters={setFilters}
          fieldConfig={fieldConfig}
        />
        <Paper sx={{ width: '100%', mb: 2 }}>
          <BaseTableToolbar
            numSelected={selected.length}
            onAdd={handleAddItem}
            onDelete={handleDeleteItems}
            onEdit={handleEditItem}
            entityName={entityName}
          />
          <Button
            onClick={generateRandomRow}
            variant="contained"
            color="primary"
            sx={{ margin: 2 }}
          >
            Generate Random Row
          </Button>
          <Button
            onClick={handleViewItem}
            variant="contained"
            color="primary"
            sx={{ margin: 2 }}
          >
            View Selected
          </Button>
          <BaseTable
            items={filteredItems}
            order={order}
            setOrder={setOrder}
            orderBy={orderBy}
            setOrderBy={setOrderBy}
            selected={selected}
            setSelected={setSelected}
            page={page}
            setPage={setPage}
            rowsPerPage={rowsPerPage}
            setRowsPerPage={setRowsPerPage}
            dense={dense}
            setDense={setDense}
            fieldConfig={fieldConfig}
          />
        </Paper>
        <FormControlLabel
          control={
            <Switch checked={dense} onChange={() => setDense(!dense)} />
          }
          label="Dense padding"
        />
        <Backdrop
          sx={{ color: '#fff', zIndex: (theme) => theme.zIndex.drawer + 1 }}
          open={loading}
        >
          <CircularProgress color="inherit" />
        </Backdrop>
      </Box>
    </Container>
  );
}
